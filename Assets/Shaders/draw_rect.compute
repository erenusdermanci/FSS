#pragma kernel draw_rect
#include "color.cginc"
#include "blocks/block.cginc"

int4 rect;
int2 world_size;
int type;
int states;
float lifetime;
float4 color;
float color_max_shift;
bool color_only;
RWStructuredBuffer<block> blocks;
RWStructuredBuffer<lockedIndex> indices;

[numthreads(8,8,1)]
void draw_rect(uint3 id : SV_DispatchThreadID)
{
    const int2 pos = int2(rect.x + id.x, world_size.y - (rect.y + id.y) - 1);
    // check world bounds
    if (pos.x >= 0 && pos.y >= 0 && pos.x < world_size.x && pos.y < world_size.y)
    {
        // check area bounds
        if (id.x < rect.z && id.y < rect.w)
        {
            const int i = pos.y * world_size.x + pos.x;
            if (!color_only)
            {
                indices[i].lock = 0;
                blocks[indices[i].index].type = type;
                blocks[indices[i].index].states = states;
                blocks[indices[i].index].lifetime = lifetime;
                blocks[indices[i].index].velocity = float2(0.0f, 0.0f);
            }
            // blocks[indices[i].index].color = shift_color(color, color_max_shift, seed(id));
            blocks[indices[i].index].color = float4(color.r / 255.0f, color.g / 255.0f, color.b / 255.0f, color.a / 255.0f);
        }
    }
}
