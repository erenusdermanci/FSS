#pragma kernel swap_behavior
#include "../constants.cginc"
#include "../blocks/block.cginc"
#include "../blocks/block_helpers.cginc"
#include "Assets/Shaders/random.cginc"

int2 position;
int2 world_size;
uint frame_count;
RWStructuredBuffer<block> blocks;
RWStructuredBuffer<lockedIndex> indices;

void swap(const in int pos, const in int npos)
{
    const int tmp_idx = indices[pos].index;
    indices[pos].index = indices[npos].index;
    indices[npos].index = tmp_idx;
}

bool lock(const in int index)
{
    int old_lock;
    InterlockedAdd(indices[index].lock, 1, old_lock);
    if (old_lock != 0)
        return false;
    return true;
}

void release(const in int index)
{
    indices[index].lock = 0;
}

block get_block(const in int index)
{
    return blocks[indices[index].index];
}

void set_block(const in int index, const in block new_block)
{
    blocks[indices[index].index] = new_block;
}

void compute_velocity(const in int3 pos, inout block self)
{
    uint s = seed(pos);
    const int3 down = get_valid_block_position(int2(pos.x, pos.y + 1), world_size);
    bool try_horizontally = false;
    if (down.z != -1)
    {
        if (lock(down.z))
        {
            if (get_block(down.z).type == air && self.velocity.y < 5.0f)
            {
                self.velocity.y += gravity * (1 + 0.1 * (rand(s) - 0.5f) * 2.0f);
                self.velocity.x *= 0.1f;
                release(down.z);
                return;
            }
            release(down.z);
        }

        const int inc[2] = { 1, -1 };
        const uint r = rand(s) > 0.5f ? 0 : 1;
        for (uint i = 0; i < 2; ++i)
        {
            const int dir = inc[(r + i) % 2];
            const int3 npos = get_valid_block_position(int2(pos.x + dir, pos.y + 1), world_size);

            if (npos.z != -1)
            {
                if (lock(npos.z))
                {
                    if (get_block(npos.z).type == air)
                    {
                        self.velocity += float2(dir * 0.7f * gravity, 0.7f * gravity);
                        release(npos.z);
                        return;
                    }
                    release(npos.z);
                }
            }
        }
        self.velocity.y = 0.0f;
        try_horizontally = true;
    }
    else
    {
        self.velocity.y = 0.0f;
        try_horizontally = true;
    }

    if (!try_horizontally)
        return;

    if (self.velocity.y == 0.0f && (self.velocity.x < 0.0f || self.velocity.x > 0.0f))
        return;

    const int inc[2] = { 1, -1 };
    const uint r = rand(s) > 0.5f ? 0 : 1;
    const int3 up = get_valid_block_position(int2(pos.x, pos.y - 1), world_size);
    if (up.z != -1)
    {
        if (lock(up.z))
        {
            if (get_block(up.z).type == water)
            {
                release(up.z);
                return;
            }
            release(up.z);
        }
    }
    for (uint i = 0; i < 2; ++i)
    {
        const int dir = inc[(r + i) % 2];
        const int3 npos = get_valid_block_position(int2(pos.x + dir, pos.y), world_size);

        if (npos.z != -1)
        {
            if (lock(npos.z))
            {
                if (get_block(npos.z).type == air && abs(self.velocity.x) < 5.0f)
                {
                    self.velocity.y = 0;
                    self.velocity.x += dir * 1.0f;
                    release(npos.z);
                    return;
                }
                release(npos.z);
            }
        }
    }
}

void move(const in int3 pos, in block self)
{
    // check down neighbours
    // add gravity
    // move according to new velocity
    // reset velocity when we hit an obstacle
    compute_velocity(pos, self);

    if (self.velocity.x != 0.0f || self.velocity.y != 0.0f)
    {
        const float2 dir = normalize(self.velocity);
        int3 last_pos = int3(0, 0, -1);
        int i = 1;
        bool obstacle = false;
        while (true)
        {
            const float2 checked_vel = i * dir;
            if (length(checked_vel) > length(self.velocity))
                break;
            const int3 next_pos = get_valid_block_position(pos.xy + floor(checked_vel), world_size);
            if (next_pos.z == -1)
                break;
            if (next_pos.x != pos.x || next_pos.y != pos.y)
            {
                if (lock(next_pos.z))
                {
                    if (get_block(next_pos.z).type != air)
                    {
                        obstacle = true;
                        release(next_pos.z);
                        break;
                    }
                    release(next_pos.z);
                }
                else
                {
                    break;
                }
            }
            last_pos = next_pos;
            ++i;
        }
        if (obstacle)
            self.velocity = float2(0.0f, 0.0f);
        set_block(pos.z, self);
        if (last_pos.z != -1)
        {
            if (lock(last_pos.z))
            {
                if (get_block(last_pos.z).type == air)
                {
                    swap(pos.z, last_pos.z);
                }
                release(last_pos.z);
            }
        }
    }
}

[numthreads(8,8,1)]
void swap_behavior(const uint3 id : SV_DispatchThreadID)
{
    const int3 pos = get_block_position(position.xy + id.xy, world_size);

    if (!lock(pos.z))
        return;
    const block self = get_block(pos.z);
    if (self.type != water)
    {
        release(pos.z);
        return;
    }
    move(pos, self);
    release(pos.z);
}
