#pragma kernel swap_behavior
#include "../block.cginc"
#include "../constants.cginc"
#include "../random.cginc"

int2 position;
int2 world_size;
uint frame_count;
RWTexture2D<float4> colors;
RWStructuredBuffer<block> blocks;

int get_index(int2 pos)
{
    return pos.y * world_size.x + pos.x;
}

int get_valid_index(int2 pos)
{
    if (pos.x < 0 || pos.y < 0 || pos.x >= world_size.x || pos.y >= world_size.y)
        return -1;
    return get_index(pos);
}

int3 get_block_position(int2 pos)
{
    return int3(pos, get_index(pos));
}

int3 get_valid_block_position(int2 pos)
{
    return int3(pos, get_valid_index(pos));
}

void swap(int3 pos, int3 npos)
{
    const block pos_block = blocks[pos.z];
    const block npos_block = blocks[npos.z];
    blocks[npos.z].type = pos_block.type;
    blocks[npos.z].lifetime = pos_block.lifetime;
    blocks[npos.z].states = pos_block.states;
    blocks[pos.z].type = npos_block.type;
    blocks[pos.z].lifetime = npos_block.lifetime;
    blocks[pos.z].states = npos_block.states;

    // reset locks when we're done
    blocks[pos.z].lock = 0;
    blocks[npos.z].lock = 0;
}

bool try_swap(int3 src, int2 dest)
{
    const int3 neighbour = get_valid_block_position(dest);
    if (neighbour.z != -1 && blocks[neighbour.z].type == air)
    {
        int old_lock = 0;
        InterlockedAdd(blocks[neighbour.z].lock, 1, old_lock);
        if (old_lock != 0)
            return false;
        swap(src, neighbour);
        return true;
    }
    return false;
}



[numthreads(8,8,1)]
void swap_behavior(uint3 id : SV_DispatchThreadID)
{
    const int3 pos = get_block_position(position.xy + id.xy);

    if (blocks[pos.z].type != water)
    {
        colors[pos.xy] = float4(0.0f, 0.0f, 0.0f, 0.0f);
        return;
    }
    else
        colors[pos.xy] = float4(15.0f/255.0f, 94.0f/255.0f, 156.0f/255.0f, 125.0f/255.0f);
    int old_lock;
    InterlockedAdd(blocks[pos.z].lock, 1, old_lock);
    if (old_lock != 0)
        return;
    uint s = seed(pos) + frame_count;
    float r = rand(s);
    if (r < 0.25f)
    {
        if (try_swap(pos, int2(pos.x, pos.y + 4)))
            return;
    }
    else if (r < 0.5f)
    {
        if (try_swap(pos, int2(pos.x, pos.y + 3)))
            return;
    }
    else if (r < 0.75f)
    {
        if (try_swap(pos, int2(pos.x, pos.y + 2)))
            return;
    }
    else
    {
        if (try_swap(pos, int2(pos.x, pos.y + 1)))
            return;
    }
    if (rand(s + 1) < 0.5f)
    {
        if (try_swap(pos, int2(pos.x - 1, pos.y + 1)))
            return;
    }
    else
    {
        if (try_swap(pos, int2(pos.x + 1, pos.y + 1)))
            return;
    }
    if (rand(s + 2) < 0.5f)
    {
        for (int i = 0; i < 4; ++i)
        {
            if (try_swap(pos, int2(pos.x - i, pos.y)))
                return;
        }
    }
    else
    {
        for (int i = 0; i < 4; ++i)
        {
            if (try_swap(pos, int2(pos.x + i, pos.y)))
                return;
        }
    }
    blocks[pos.z].lock = 0;
}
