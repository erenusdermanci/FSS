#pragma kernel swap_behavior
#include "../constants.cginc"
#include "../random.cginc"
#include "../blocks/block.cginc"
#include "../blocks/block_helpers.cginc"

int2 position;
int2 world_size;
uint frame_count;
RWStructuredBuffer<block> blocks;

void swap(int3 pos, int3 npos)
{
    const int type = blocks[pos.z].type;
    const int states = blocks[pos.z].states;
    const float lifetime = blocks[pos.z].lifetime;
    const float4 color = blocks[pos.z].color;

    blocks[pos.z].type = blocks[npos.z].type;
    blocks[pos.z].lifetime = blocks[npos.z].lifetime;
    blocks[pos.z].states = blocks[npos.z].states;
    blocks[pos.z].color = blocks[npos.z].color;

    blocks[npos.z].type = type;
    blocks[npos.z].lifetime = lifetime;
    blocks[npos.z].states = states;
    blocks[npos.z].color = color;

    // release locks when we're done
    blocks[pos.z].lock = 0;
    blocks[npos.z].lock = 0;
}

bool try_swap(int3 src, int2 dest)
{
    const int3 neighbour = get_valid_block_position(dest, world_size);
    if (neighbour.z != -1)
    {
        int old_lock = 0;
        InterlockedAdd(blocks[neighbour.z].lock, 1, old_lock);
        if (old_lock != 0)
            return false;
        if (blocks[neighbour.z].type == air)
        {
            swap(src, neighbour);
            return true;
        }

        blocks[neighbour.z].lock = 0;
        return false;
    }
    return false;
}

[numthreads(8,8,1)]
void swap_behavior(uint3 id : SV_DispatchThreadID)
{
    const int3 pos = get_block_position(position.xy + id.xy, world_size);

    if (blocks[pos.z].type != water)
        return;
    int old_lock;
    InterlockedAdd(blocks[pos.z].lock, 1, old_lock);
    if (old_lock != 0)
        return;
    if (blocks[pos.z].type != water)
    {
        blocks[pos.z].lock = 0;
        return;
    }
    uint s = seed(pos) + frame_count;
    float r = rand(s);
    if (r < 0.25f)
    {
        if (try_swap(pos, int2(pos.x, pos.y + 4)))
            return;
    }
    else if (r < 0.5f)
    {
        if (try_swap(pos, int2(pos.x, pos.y + 3)))
            return;
    }
    else if (r < 0.75f)
    {
        if (try_swap(pos, int2(pos.x, pos.y + 2)))
            return;
    }
    else
    {
        if (try_swap(pos, int2(pos.x, pos.y + 1)))
            return;
    }
    if (rand(s + 1) < 0.5f)
    {
        if (try_swap(pos, int2(pos.x - 1, pos.y + 1)))
            return;
    }
    else
    {
        if (try_swap(pos, int2(pos.x + 1, pos.y + 1)))
            return;
    }
    if (rand(s + 2) < 0.5f)
    {
        for (int i = 0; i < 4; ++i)
        {
            if (try_swap(pos, int2(pos.x - i, pos.y)))
                return;
        }
    }
    else
    {
        for (int i = 0; i < 4; ++i)
        {
            if (try_swap(pos, int2(pos.x + i, pos.y)))
                return;
        }
    }
    blocks[pos.z].lock = 0;
}
